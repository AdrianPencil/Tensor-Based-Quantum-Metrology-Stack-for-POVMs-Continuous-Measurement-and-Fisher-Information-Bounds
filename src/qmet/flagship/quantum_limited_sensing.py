"""
Flagship: Fisher bounds + "how close do we get?"

This file provides a compact comparison between:
- classical Fisher information from a chosen readout model
- a quantum Fisher information (QFI) benchmark for a qubit phase imprint

For a single qubit under unitary phase encoding generated by G = (t/2) sigma_z,
with an optimal initial state (e.g. |+>), the QFI for omega is:
    F_Q(omega) = t^2

For independent samples at times t_i, additivity gives:
    F_Q,total = sum_i t_i^2
"""

from dataclasses import dataclass

import numpy as np
import numpy.typing as npt

from ..protocols.ramsey import RamseyParams, ramsey_signal_and_jac_omega
from ..estimation.fisher import fisher_scalar_gaussian_iid

__all__ = [
    "QuantumLimitGap",
    "quantum_fisher_qubit_omega_times",
    "quantum_limit_gap_for_ramsey",
]


@dataclass(frozen=True, slots=True)
class QuantumLimitGap:
    """
    Comparison between classical Fisher and a QFI benchmark.
    """

    classical_fisher: float
    quantum_fisher: float

    def ratio(self) -> float:
        """Return classical / quantum (closer to 1 is better)."""
        if self.quantum_fisher <= 0.0:
            return float("nan")
        return float(self.classical_fisher / self.quantum_fisher)

    def gap(self) -> float:
        """Return quantum - classical (>= 0 means below the quantum benchmark)."""
        return float(self.quantum_fisher - self.classical_fisher)


def quantum_fisher_qubit_omega_times(t_s: npt.NDArray[np.float64]) -> float:
    """
    QFI benchmark for omega for a qubit phase imprint at times t_i:
        F_Q = sum_i t_i^2

    Args:
        t_s: time samples (n,).

    Returns:
        quantum Fisher information as float.
    """
    tt = np.asarray(t_s, dtype=np.float64)
    if tt.ndim != 1:
        raise ValueError("t_s must be 1D.")
    return float(np.sum(tt * tt))


def quantum_limit_gap_for_ramsey(
    t_s: npt.NDArray[np.float64],
    omega: float,
    params: RamseyParams,
    sigma_y: float,
) -> QuantumLimitGap:
    """
    Compute a simple "distance to quantum limit" for a Ramsey readout model.

    Classical Fisher is computed from the Ramsey mean signal derivative and
    Gaussian IID readout noise:
        F_C = (1/sigma_y^2) * sum_i (dmu_i/domega)^2

    Quantum Fisher benchmark is:
        F_Q = sum_i t_i^2

    Args:
        t_s: time samples (n,).
        omega: angular frequency (rad/s).
        params: RamseyParams.
        sigma_y: readout std (> 0).

    Returns:
        QuantumLimitGap.
    """
    tt = np.asarray(t_s, dtype=np.float64)
    if tt.ndim != 1:
        raise ValueError("t_s must be 1D.")
    s = float(sigma_y)
    if s <= 0.0:
        raise ValueError("sigma_y must be > 0.")

    _, dmu = ramsey_signal_and_jac_omega(t=tt, omega=float(omega), params=params)
    f_c = fisher_scalar_gaussian_iid(dmu_dtheta=dmu, sigma=s)
    f_q = quantum_fisher_qubit_omega_times(tt)
    return QuantumLimitGap(classical_fisher=float(f_c), quantum_fisher=float(f_q))
